name: SecurityKane Gitleaks Composite Action
description: Run gitleaks and produce a merged JSON report with metadata
runs:
  using: composite
  steps:
    - name: Install gitleaks and jq
      shell: bash
      run: |
        set -euo pipefail
        sudo apt-get update
        sudo apt-get install -y jq curl
        GITLEAKS_VERSION="${GITLEAKS_VERSION:-v8.18.4}"
        VERSION_NO_V="${GITLEAKS_VERSION#v}"
        # Download gitleaks with retry logic and proper error handling
        curl -fsSL --retry 3 --retry-all-errors --connect-timeout 10 \
          -o gitleaks.tar.gz \
          "https://github.com/gitleaks/gitleaks/releases/download/${GITLEAKS_VERSION}/gitleaks_${VERSION_NO_V}_linux_x64.tar.gz"
        tar -xzf gitleaks.tar.gz gitleaks
        sudo mv gitleaks /usr/local/bin/gitleaks
        gitleaks version
    - name: Run gitleaks (git history)
      shell: bash
      run: |
        set -euo pipefail
        gitleaks detect --source . --no-color --report-format=json --report-path gitleaks.json --exit-code 0
        test -s gitleaks.json || echo "[]" > gitleaks.json
    - name: Merge findings
      shell: bash
      run: |
        set -euo pipefail
        jq -s 'map(if type=="array" then . else [] end) | add' gitleaks.json > findings.json
    - name: Build merged JSON
      shell: bash
      env:
        SK_TENANT_ID: ${{ env.SK_TENANT_ID }}
        GITHUB_REPOSITORY: ${{ github.repository }}
        GITHUB_SHA: ${{ github.sha }}
        GITHUB_RUN_ID: ${{ github.run_id }}
        GITHUB_RUN_ATTEMPT: ${{ github.run_attempt }}
        GITHUB_REF: ${{ github.ref }}
        GITHUB_REF_NAME: ${{ github.ref_name }}
        GITHUB_ACTOR: ${{ github.actor }}
        GITHUB_SERVER_URL: ${{ github.server_url }}
      run: |
        set -euo pipefail
        GEN_AT="$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
        RUN_URL="${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}"
        jq -n \
          --arg tenant_id "${SK_TENANT_ID:-}" \
          --arg repository "${GITHUB_REPOSITORY}" \
          --arg commit_sha "${GITHUB_SHA}" \
          --arg run_id "${GITHUB_RUN_ID}" \
          --arg run_attempt "${GITHUB_RUN_ATTEMPT}" \
          --arg ref "${GITHUB_REF}" \
          --arg ref_name "${GITHUB_REF_NAME}" \
          --arg actor "${GITHUB_ACTOR}" \
          --arg run_url "${RUN_URL}" \
          --arg generated_at "${GEN_AT}" \
          --slurpfile findings findings.json \
          '{
            tenant_id: $tenant_id,
            repository: $repository,
            commit_sha: $commit_sha,
            run_id: $run_id,
            run_attempt: $run_attempt,
            ref: $ref,
            ref_name: $ref_name,
            actor: $actor,
            run_url: $run_url,
            generated_at: $generated_at,
            findings: $findings[0]
          }' > securitykane_gitleaks.json
    - name: Post to backend and upload to S3
      shell: bash
      env:
        ACTIONS_ID_TOKEN_REQUEST_URL: ${{ env.ACTIONS_ID_TOKEN_REQUEST_URL }}
        ACTIONS_ID_TOKEN_REQUEST_TOKEN: ${{ env.ACTIONS_ID_TOKEN_REQUEST_TOKEN }}
        GITHUB_REPOSITORY: ${{ github.repository }}
      run: |
        set -euo pipefail

        # Request OIDC ID token from GitHub Actions (secure alternative to GITHUB_TOKEN)
        # This token is cryptographically signed and can be verified server-side
        # Requires workflow to have 'id-token: write' permission
        echo "Requesting OIDC ID token..."
        OIDC_TOKEN=$(curl -fsSL --retry 3 --retry-all-errors \
          -H "Authorization: Bearer ${ACTIONS_ID_TOKEN_REQUEST_TOKEN}" \
          "${ACTIONS_ID_TOKEN_REQUEST_URL}&audience=securitykane" \
          | jq -r '.value')

        if [ -z "$OIDC_TOKEN" ] || [ "$OIDC_TOKEN" = "null" ]; then
          echo "ERROR: Failed to obtain OIDC ID token"
          echo "Ensure your workflow has 'id-token: write' permission"
          exit 1
        fi

        # Post to backend with retry logic
        # NOTE: smee.io endpoint is for DEVELOPMENT ONLY - do not use in production
        # smee.io can see your payload. Use your own backend endpoint for production.
        echo "Requesting presigned S3 URL from backend..."
        RETRY_COUNT=0
        MAX_RETRIES=3
        RETRY_DELAY=2

        while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
          RESPONSE=$(curl -fsSL --connect-timeout 10 -X POST \
            -H "Content-Type: application/json" \
            -d "{\"id_token\":\"${OIDC_TOKEN}\",\"repository\":\"${GITHUB_REPOSITORY}\"}" \
            https://smee.io/J0WcDeqyS7aQ7m5x/api/integrations/github/tenant-info/ 2>&1) && break

          RETRY_COUNT=$((RETRY_COUNT + 1))
          if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
            echo "Backend request failed, retrying in ${RETRY_DELAY}s... (attempt $RETRY_COUNT/$MAX_RETRIES)"
            sleep $RETRY_DELAY
            RETRY_DELAY=$((RETRY_DELAY * 2))
          else
            echo "ERROR: Failed to get presigned URL after $MAX_RETRIES attempts"
            echo "Response: $RESPONSE"
            exit 1
          fi
        done

        # Validate presigned URL exists and is not null
        S3_URL=$(echo "$RESPONSE" | jq -r '.presigned_url')
        if [ -z "$S3_URL" ] || [ "$S3_URL" = "null" ]; then
          echo "ERROR: Presigned URL is missing or null in backend response"
          echo "Response: $RESPONSE"
          exit 1
        fi

        echo "Presigned URL obtained successfully"

        # Upload to S3 with proper error handling
        # Headers must match what was pre-signed on the backend
        echo "Uploading results to S3..."
        if ! curl -fsSL --retry 3 --retry-all-errors --connect-timeout 30 -X PUT \
          --data-binary @securitykane_gitleaks.json \
          -H "Content-Type: application/json" \
          "${S3_URL}"; then
          echo "ERROR: Failed to upload to S3"
          exit 1
        fi

        echo "Upload completed successfully"
